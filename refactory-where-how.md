# 重构之where-how
[重构之what-why-when](learnrecording/refactor-what-why-when.md)提到过对于重构可以用5个问题来引导对重构知识的学习与章握：
* 什么是重构？（what)
* 么重构？（why) 
* 时候重构？（when) 
* 地方重构？（where)
* 何重构？（how)

[重构之what-why-when](learnrecording/refactor-what-why-when.md)回答了前面三个，本文来回答最后两个问题:
* 在什么地方重构?
* 如何重构? 
最后一篇文章的体会其实是最少的，因为了解了前面的内容，后面的内容是术的层面，就是工具了，平时没事儿拿出来看看，或者在准备重构的时候，记忆中有那么一种针对当前情况的重构手法，翻开书打开看看查找实践就可以了。

但是真正的重构高手，**要把这些重构手法烂熟于心，熟练掌握各种手法，在实践中多运用，也就是学会各种基本招式，最后将所有的招式融会贯通，到达武林高手的无招胜有招的水平。** 当然这需要一个相对时间较长的学习，实践，总结，再实践的过程，对知识的学习，要有耐心。

## 什么地方重构？
在书中第三章作者专门用一个词语来表达在什么地方我们应该重构。我们要做的就是培养嗅觉，一看到这段代码，就能看出这段代码是有重构空间的，或者说发现这段代码是明显不合理的，找到合适的时间点一定把它重构掉。** “坏味道”是从代码中发出的不好信号，你有能力识别出来么？** 就我们A程序而言，可以嗅到的坏味道有下面的类型：重复代码，过长函数，过大的类，过长参数列，过多的注释等。而且像过长的参数列的修改已经让不少同事体会到了痛苦,所以，在后续版本继续迭代开发的过程中，我们可以一步一步地重构它们，最终让它们变得更易理解与维护.

作者对于重构的观点一直秉承“测试是必备条件”，这个对实际情况的我们来说，操作起来有困难，一些需要测试的内容，重构前务必要想好，**谨记的一点是在一步一步前进的过程中，让步骤小到可控的范围，不要太相信自己的能力，结果很有可能就是在调试的过程上花费非常多的时间。**

## 如何重构?
也就是怎样重构，重构的手法太多了，针对第三章提到的坏味道，有非常具体的操作步骤在书中列出，在此就不一一列举了，看看书就知道了。

举个我们实践中比较讨厌的例子一过长函数。对于函数的长短,其实没有那个规范说一个函数宄竟要多长，具体限制长度也没有意义，函数最重要的性质应该是功能上的独立性，也就是函数只是做一件事情，只要把这件事情做好就行了，而不是因为一个函数超过某人认定的长度值（比如30行），就按照这个长度值（30行）去裁剪成一个一个的小函数。让函数好理解的另一个重要特点是函数名字恰如其分地表述了其要做的事情,也就是命名直达其意

如果一个函数确实长了点，不利于我们在开发中加东西了，或者那个长函数里面有一部分代码需要在新的函数里面应用，为了不使函数更长或者不让程序有重复代码，我们准备进行长函数裁剪。在这个时候，要注意的是原则：功能上的独立性，我们可以运用提取方法(Extract Method)的重构手法提取出新函数，让原函数调用新函数。为了提升可读性，你可以还会运用(Replace Temp with Query)手法来替换新函数中的局部变量。当然还有可能的是，新函数的参数列表太长了，你可能要运用过长参数列表裁剪相关的手法来进一步对提取出来的函数继续进行重构。

很简单，确实如此，其实在进行重构时，你可能都不知道你要走到哪儿去，因为你用了一种重构方法后，你能看到之前看不到的更多的需要重构的地方，不过那肯定是好的，因为你在持续地改进与优化代码，结果就是整个软件质量不断提升，也有利于软件较快速的向前迭代。

总结一下：
* 重构从散发出“坏味道”的代码开始，要培养能够识别代码坏味道“的能力
* 具体的重构手法与步骤在书中都有体现，需要在实践中查阅与总结反思
* 要成为高手，先得掌握好基本招式，最后再融会贯通，做到无招胜有招。
